{
  if (length != 0) {
    if (ourBreaks.length < length) {
      ourBreaks=new byte[length];
    }
    final byte[] breaks=ourBreaks;
    myLineBreaker.setLineBreaks(data,offset,length,breaks);
    final ZLTextElement hSpace=ZLTextElement.HSpace;
    final ArrayList<ZLTextElement> elements=myElements;
    char ch;
    char previousChar=data[offset];
    int spaceState=NO_SPACE;
    int wordStart=0;
    for (int index=0; index < length; ++index) {
      ch=data[offset + index];
      if (Character.isSpace(ch)) {
        if (index > 0 && spaceState == NO_SPACE) {
          addWord(data,offset + wordStart,index - wordStart,myOffset + wordStart);
        }
        spaceState=SPACE;
      }
 else {
switch (spaceState) {
case SPACE:
          elements.add(hSpace);
        wordStart=index;
      break;
case NO_SPACE:
    if (index > 0 && breaks[index - 1] != LineBreaker.NOBREAK && previousChar != '-' && index != wordStart) {
      addWord(data,offset + wordStart,index - wordStart,myOffset + wordStart);
      wordStart=index;
    }
  break;
}
spaceState=NO_SPACE;
}
}
switch (spaceState) {
case SPACE:
elements.add(hSpace);
break;
case NO_SPACE:
addWord(data,offset + wordStart,length - wordStart,myOffset + wordStart);
break;
}
myOffset+=length;
}
}
