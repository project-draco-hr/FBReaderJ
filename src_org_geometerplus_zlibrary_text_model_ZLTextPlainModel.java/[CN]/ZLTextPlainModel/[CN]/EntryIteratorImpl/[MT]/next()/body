{
  int dataOffset=myDataOffset;
  char[] data=myStorage.block(myDataIndex);
  if (dataOffset == data.length) {
    data=myStorage.block(++myDataIndex);
    dataOffset=0;
  }
  byte type=(byte)data[dataOffset];
  if (type == 0) {
    data=myStorage.block(++myDataIndex);
    dataOffset=0;
    type=(byte)data[0];
  }
  myType=type;
  ++dataOffset;
switch (type) {
case ZLTextParagraph.Entry.TEXT:
{
      int textLength=(int)data[dataOffset++];
      textLength+=(((int)data[dataOffset++]) << 16);
      textLength=Math.min(textLength,data.length - dataOffset);
      myTextLength=textLength;
      myTextData=data;
      myTextOffset=dataOffset;
      dataOffset+=textLength;
      break;
    }
case ZLTextParagraph.Entry.CONTROL:
{
    short kind=(short)data[dataOffset++];
    myControlKind=(byte)kind;
    myControlIsStart=(kind & 0x0100) == 0x0100;
    myHyperlinkType=0;
    break;
  }
case ZLTextParagraph.Entry.HYPERLINK_CONTROL:
{
  final short kind=(short)data[dataOffset++];
  myControlKind=(byte)kind;
  myControlIsStart=true;
  myHyperlinkType=(byte)(kind >> 8);
  final short labelLength=(short)data[dataOffset++];
  myHyperlinkId=new String(data,dataOffset,labelLength);
  dataOffset+=labelLength;
  break;
}
case ZLTextParagraph.Entry.IMAGE:
{
final short vOffset=(short)data[dataOffset++];
final short len=(short)data[dataOffset++];
final String id=new String(data,dataOffset,len);
dataOffset+=len;
final boolean isCover=data[dataOffset++] != 0;
myImageEntry=new ZLImageEntry(myImageMap,id,vOffset,isCover);
break;
}
case ZLTextParagraph.Entry.FIXED_HSPACE:
myFixedHSpaceLength=(short)data[dataOffset++];
break;
case ZLTextParagraph.Entry.STYLE_CSS:
case ZLTextParagraph.Entry.STYLE_OTHER:
{
final ZLTextStyleEntry entry=type == ZLTextParagraph.Entry.STYLE_CSS ? new ZLTextCSSStyleEntry() : new ZLTextOtherStyleEntry();
final short mask=(short)data[dataOffset++];
for (int i=0; i < NUMBER_OF_LENGTHS; ++i) {
if (ZLTextStyleEntry.isFeatureSupported(mask,i)) {
final short size=(short)data[dataOffset++];
final byte unit=(byte)data[dataOffset++];
entry.setLength(i,size,unit);
}
}
if (ZLTextStyleEntry.isFeatureSupported(mask,ALIGNMENT_TYPE)) {
final short value=(short)data[dataOffset++];
entry.setAlignmentType((byte)(value & 0xFF));
}
if (ZLTextStyleEntry.isFeatureSupported(mask,FONT_FAMILY)) {
final short listLength=(short)data[dataOffset++];
final ArrayList<String> families=new ArrayList<String>(listLength);
for (short i=0; i < listLength; ++i) {
final short familyLength=(short)data[dataOffset++];
families.add(new String(data,dataOffset,familyLength));
dataOffset+=familyLength;
}
entry.setFontFamilies(families);
}
if (ZLTextStyleEntry.isFeatureSupported(mask,FONT_STYLE_MODIFIER)) {
final short value=(short)data[dataOffset++];
entry.setFontModifiers((byte)(value & 0xFF),(byte)((value >> 8) & 0xFF));
}
myStyleEntry=entry;
}
case ZLTextParagraph.Entry.STYLE_CLOSE:
break;
case ZLTextParagraph.Entry.RESET_BIDI:
break;
case ZLTextParagraph.Entry.AUDIO:
break;
case ZLTextParagraph.Entry.VIDEO:
{
myVideoEntry=new ZLVideoEntry();
final short mapSize=(short)data[dataOffset++];
for (short i=0; i < mapSize; ++i) {
short len=(short)data[dataOffset++];
final String mime=new String(data,dataOffset,len);
dataOffset+=len;
len=(short)data[dataOffset++];
final String src=new String(data,dataOffset,len);
dataOffset+=len;
myVideoEntry.addSource(mime,src);
}
break;
}
}
++myCounter;
myDataOffset=dataOffset;
}
