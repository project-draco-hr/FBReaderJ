{
  final TreeMap<String,char[]> entityMap=new TreeMap<String,char[]>();
  entityMap.put("amp",new char[]{'&'});
  entityMap.put("apos",new char[]{'\''});
  entityMap.put("gt",new char[]{'>'});
  entityMap.put("lt",new char[]{'<'});
  entityMap.put("quot",new char[]{'\"'});
  final InputStreamReader streamReader=myStreamReader;
  final ZLXMLReader xmlReader=myXMLReader;
  final char[] buffer=myBuffer;
  final StringBuilder tagName=new StringBuilder();
  final StringBuilder attributeName=new StringBuilder();
  final StringBuilder attributeValue=new StringBuilder();
  final StringBuilder entityName=new StringBuilder();
  final TreeMap<String,String> attributes=new TreeMap<String,String>();
  int state=START_DOCUMENT;
  int savedState=START_DOCUMENT;
  while (true) {
    int count=streamReader.read(buffer);
    if (count <= 0) {
      ourStrings.clear();
      return;
    }
    int startPosition=0;
    for (int i=0; i < count; ++i) {
      char c=buffer[i];
switch (state) {
case START_DOCUMENT:
        while ((c != '<') && (++i < count)) {
          c=buffer[i];
        }
      if (c == '<') {
        state=LANGLE;
        startPosition=i + 1;
      }
    break;
case LANGLE:
switch (c) {
case '/':
    state=END_TAG;
  startPosition=i + 1;
break;
case '!':
case '?':
state=COMMENT;
break;
default :
state=START_TAG;
startPosition=i;
break;
}
break;
case COMMENT:
while ((c != '>') && (++i < count)) {
c=buffer[i];
}
if (c == '>') {
state=TEXT;
startPosition=i + 1;
}
break;
case START_TAG:
while (true) {
if (isWhitespace(c)) {
state=WS_AFTER_START_TAG_NAME;
appendToName(tagName,buffer,startPosition,i);
break;
}
 else if (c == '>') {
appendToName(tagName,buffer,startPosition,i);
processStartTag(xmlReader,tagName,attributes);
state=TEXT;
startPosition=i + 1;
break;
}
 else if (c == '/') {
state=SLASH;
appendToName(tagName,buffer,startPosition,i);
processFullTag(xmlReader,tagName,attributes);
break;
}
 else if (c == '&') {
savedState=START_TAG;
state=ENTITY_REF;
startPosition=i + 1;
break;
}
 else if (++i == count) {
appendToName(tagName,buffer,startPosition,i);
break;
}
c=buffer[i];
}
break;
case WS_AFTER_START_TAG_NAME:
if (c == '>') {
processStartTag(xmlReader,tagName,attributes);
state=TEXT;
startPosition=i + 1;
}
 else if (c == '/') {
state=SLASH;
processFullTag(xmlReader,tagName,attributes);
}
 else if (!isWhitespace(c)) {
state=ATTRIBUTE_NAME;
startPosition=i;
}
break;
case ATTRIBUTE_NAME:
while (true) {
if (c == '=') {
state=WAIT_ATTRIBUTE_VALUE;
break;
}
 else if (c == '&') {
savedState=ATTRIBUTE_NAME;
state=ENTITY_REF;
startPosition=i + 1;
break;
}
 else if (isWhitespace(c)) {
state=WAIT_EQUALS;
break;
}
 else if (++i == count) {
break;
}
c=buffer[i];
}
appendToName(attributeName,buffer,startPosition,i);
break;
case WAIT_EQUALS:
if (c == '=') {
state=WAIT_ATTRIBUTE_VALUE;
}
break;
case WAIT_ATTRIBUTE_VALUE:
if (c == '"') {
state=ATTRIBUTE_VALUE;
startPosition=i + 1;
}
break;
case ATTRIBUTE_VALUE:
while ((c != '"') && (c != '&') && (++i < count)) {
c=buffer[i];
}
appendToName(attributeValue,buffer,startPosition,i);
if (c == '"') {
state=WS_AFTER_START_TAG_NAME;
attributes.put(convertToString(attributeName),convertToString(attributeValue));
}
 else if (c == '&') {
savedState=ATTRIBUTE_VALUE;
state=ENTITY_REF;
startPosition=i + 1;
}
break;
case ENTITY_REF:
while ((c != ';') && (++i < count)) {
c=buffer[i];
}
appendToName(entityName,buffer,startPosition,i);
if (c == ';') {
state=savedState;
startPosition=i + 1;
final String name=convertToString(entityName);
char[] value=entityMap.get(name);
if (value == null) {
if ((name.length() > 0) && (name.charAt(0) == '#')) {
try {
int number;
if (name.charAt(1) == 'x') {
number=Integer.parseInt(name.substring(2),16);
}
 else {
number=Integer.parseInt(name.substring(1));
}
value=new char[]{(char)number};
entityMap.put(name,value);
}
 catch (NumberFormatException e) {
}
}
}
if (value != null) {
switch (state) {
case ATTRIBUTE_VALUE:
appendToName(attributeValue,value,0,value.length);
break;
case ATTRIBUTE_NAME:
appendToName(attributeName,value,0,value.length);
break;
case START_TAG:
case END_TAG:
appendToName(tagName,value,0,value.length);
break;
case TEXT:
xmlReader.characterDataHandler(value,0,value.length);
break;
}
}
}
break;
case SLASH:
if (c == '>') {
state=TEXT;
startPosition=i + 1;
}
break;
case END_TAG:
while (true) {
if (c == '>') {
appendToName(tagName,buffer,startPosition,i);
processEndTag(xmlReader,tagName);
state=TEXT;
startPosition=i + 1;
break;
}
 else if (c == '&') {
savedState=END_TAG;
state=ENTITY_REF;
startPosition=i + 1;
break;
}
 else if (isWhitespace(c)) {
appendToName(tagName,buffer,startPosition,i);
state=WS_AFTER_END_TAG_NAME;
break;
}
 else if (++i == count) {
appendToName(tagName,buffer,startPosition,i);
break;
}
c=buffer[i];
}
break;
case WS_AFTER_END_TAG_NAME:
if (c == '>') {
state=TEXT;
processEndTag(xmlReader,tagName);
startPosition=i + 1;
}
break;
case TEXT:
while ((c != '<') && (c != '&') && (++i < count)) {
c=buffer[i];
}
if (i > startPosition) {
if (c == '<') {
xmlReader.characterDataHandlerFinal(buffer,startPosition,i - startPosition);
}
 else {
xmlReader.characterDataHandler(buffer,startPosition,i - startPosition);
}
}
if (c == '<') {
state=LANGLE;
}
 else if (c == '&') {
savedState=TEXT;
state=ENTITY_REF;
startPosition=i + 1;
}
break;
}
}
}
}
