{
  System.err.println("SYNCHRONIZER BINDED TO LIBRARY");
  myCollection.addListener(this);
  if (ourSynchronizationThread == null) {
    ourSynchronizationThread=new Thread(){
      public void run(){
        try {
          System.err.println("HELLO THREAD");
          myHashesFromServer.clear();
          try {
            myNetworkContext.perform(new PostRequest("all.hashes",null){
              @Override public void processResponse(              Object response){
                myHashesFromServer.addAll((List)response);
              }
            }
);
            System.err.println("RECEIVED: " + myHashesFromServer.size() + " HASHES");
          }
 catch (          Exception e) {
            e.printStackTrace();
            System.err.println("DO NOT SYNCHRONIZE: ALL HASHES REQUEST FAILED");
            return;
          }
          System.err.println("START SYNCRONIZATION");
          for (BookQuery q=new BookQuery(new Filter.Empty(),20); ; q=q.next()) {
            final List<Book> books=myCollection.books(q);
            if (books.isEmpty()) {
              break;
            }
            for (            Book b : books) {
              addBook(b);
            }
          }
          while (!myQueue.isEmpty()) {
            final Book book=myQueue.remove(0);
            if (myProcessed.contains(book)) {
              continue;
            }
            myProcessed.add(book);
            System.err.println("Processing " + book.getTitle() + " ["+ book.File.getPath()+ "]");
            uploadBookToServer(book.File.getPhysicalFile());
          }
        }
  finally {
          System.err.println("BYE-BYE THREAD");
          ourSynchronizationThread=null;
        }
      }
    }
;
    ourSynchronizationThread.setPriority(Thread.MIN_PRIORITY);
    ourSynchronizationThread.start();
  }
}
