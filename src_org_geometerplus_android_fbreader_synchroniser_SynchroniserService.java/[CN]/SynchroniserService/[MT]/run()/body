{
  System.err.println("SYNCHRONIZER BINDED TO LIBRARY");
  myCollection.addListener(this);
  if (ourSynchronizationThread == null) {
    ourSynchronizationThread=new Thread(){
      public void run(){
        try {
          System.err.println("HELLO THREAD");
          myActualHashesFromServer.clear();
          myDeletedHashesFromServer.clear();
          try {
            myNetworkContext.perform(new PostRequest("all.hashes",null){
              @Override public void processResponse(              Object response){
                final Map<String,List<String>> map=(Map<String,List<String>>)response;
                myActualHashesFromServer.addAll(map.get("actual"));
                myDeletedHashesFromServer.addAll(map.get("deleted"));
              }
            }
);
            System.err.println(String.format("RECEIVED: %s/%s HASHES",myActualHashesFromServer.size(),myDeletedHashesFromServer.size()));
          }
 catch (          Exception e) {
            e.printStackTrace();
            System.err.println("DO NOT SYNCHRONIZE: ALL HASHES REQUEST FAILED");
            return;
          }
          System.err.println("START SYNCRONIZATION " + new Date());
          for (BookQuery q=new BookQuery(new Filter.Empty(),20); ; q=q.next()) {
            final List<Book> books=myCollection.books(q);
            if (books.isEmpty()) {
              break;
            }
            for (            Book b : books) {
              addBook(b);
            }
          }
          while (!myQueue.isEmpty()) {
            final Book book=myQueue.remove(0);
            if (myProcessed.contains(book)) {
              continue;
            }
            myProcessed.add(book);
            System.err.println("Processing " + book.getTitle() + " ["+ book.File.getPath()+ "]");
            uploadBookToServer(book);
          }
        }
  finally {
          System.err.println("BYE-BYE THREAD " + new Date());
          ourSynchronizationThread=null;
        }
      }
    }
;
    ourSynchronizationThread.setPriority(Thread.MIN_PRIORITY);
    ourSynchronizationThread.start();
  }
}
