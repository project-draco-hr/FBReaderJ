{
  myCollection.addListener(this);
  if (ourSynchronizationThread == null) {
    ourSynchronizationThread=new Thread(){
      public void run(){
        try {
          sleep(10000);
        }
 catch (        InterruptedException e) {
        }
        final long start=System.currentTimeMillis();
        int count=0;
        final Map<SyncStatus,Integer> statusCounts=new HashMap<SyncStatus,Integer>();
        try {
          clearHashTables();
          for (BookQuery q=new BookQuery(new Filter.Empty(),20); ; q=q.next()) {
            final List<Book> books=myCollection.books(q);
            if (books.isEmpty()) {
              break;
            }
            for (            Book b : books) {
              addBook(b);
            }
          }
          while (!myQueue.isEmpty()) {
            final Book book=myQueue.remove(0);
            if (myProcessed.contains(book)) {
              continue;
            }
            myProcessed.add(book);
            ++count;
            final SyncStatus status=uploadBookToServer(book);
            if (status.Label != null) {
              for (              String label : SyncStatus.AllLabels) {
                if (status.Label.equals(label)) {
                  book.addLabel(label);
                }
 else {
                  book.removeLabel(label);
                }
              }
              myCollection.saveBook(book);
            }
            final Integer sc=statusCounts.get(status);
            statusCounts.put(status,sc != null ? sc + 1 : 1);
          }
        }
  finally {
          System.err.println("SYNCHRONIZATION FINISHED IN " + (System.currentTimeMillis() - start) + "msecs");
          System.err.println("TOTAL BOOKS PROCESSED: " + count);
          for (          SyncStatus value : SyncStatus.values()) {
            System.err.println("STATUS " + value + ": "+ statusCounts.get(value));
          }
          ourSynchronizationThread=null;
        }
      }
    }
;
    ourSynchronizationThread.setPriority(Thread.MIN_PRIORITY);
    ourSynchronizationThread.start();
  }
}
