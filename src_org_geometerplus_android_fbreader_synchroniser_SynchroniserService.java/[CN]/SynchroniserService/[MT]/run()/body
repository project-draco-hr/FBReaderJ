{
  myCollection.addListener(this);
  if (ourSynchronizationThread == null) {
    ourSynchronizationThread=new Thread(){
      public void run(){
        final long start=System.currentTimeMillis();
        int count=0;
        final Map<SyncStatus,Integer> statusCounts=new HashMap<SyncStatus,Integer>();
        try {
          myActualHashesFromServer.clear();
          myDeletedHashesFromServer.clear();
          try {
            myNetworkContext.perform(new PostRequest("all.hashes",null){
              @Override public void processResponse(              Object response){
                final Map<String,List<String>> map=(Map<String,List<String>>)response;
                myActualHashesFromServer.addAll(map.get("actual"));
                myDeletedHashesFromServer.addAll(map.get("deleted"));
              }
            }
);
            System.err.println(String.format("RECEIVED: %s/%s HASHES",myActualHashesFromServer.size(),myDeletedHashesFromServer.size()));
          }
 catch (          Exception e) {
            e.printStackTrace();
            System.err.println("DO NOT SYNCHRONIZE: ALL HASHES REQUEST FAILED");
            return;
          }
          for (BookQuery q=new BookQuery(new Filter.Empty(),20); ; q=q.next()) {
            final List<Book> books=myCollection.books(q);
            if (books.isEmpty()) {
              break;
            }
            for (            Book b : books) {
              addBook(b);
            }
          }
          while (!myQueue.isEmpty()) {
            final Book book=myQueue.remove(0);
            if (myProcessed.contains(book)) {
              continue;
            }
            myProcessed.add(book);
            ++count;
            final SyncStatus status=uploadBookToServer(book);
            if (status.Label != null) {
              for (              String label : SyncStatus.AllLabels) {
                if (status.Label.equals(label)) {
                  book.addLabel(label);
                }
 else {
                  book.removeLabel(label);
                }
              }
              myCollection.saveBook(book);
            }
            final Integer sc=statusCounts.get(status);
            statusCounts.put(status,sc != null ? sc + 1 : 1);
          }
        }
  finally {
          System.err.println("SYNCHRONIZATION FINISHED IN " + (System.currentTimeMillis() - start) + "msecs");
          System.err.println("TOTAL BOOKS PROCESSED: " + count);
          for (          SyncStatus value : SyncStatus.values()) {
            System.err.println("STATUS " + value + ": "+ statusCounts.get(value));
          }
          ourSynchronizationThread=null;
        }
      }
    }
;
    ourSynchronizationThread.setPriority(Thread.MIN_PRIORITY);
    ourSynchronizationThread.start();
  }
}
