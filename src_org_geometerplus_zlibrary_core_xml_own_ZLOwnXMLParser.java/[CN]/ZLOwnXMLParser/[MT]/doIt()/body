{
  final ZLXMLReader xmlReader=myXMLReader;
  final HashMap entityMap=getDTDMap(xmlReader.externalDTDs());
  final InputStreamReader streamReader=myStreamReader;
  final boolean processNamespaces=myProcessNamespaces;
  HashMap oldNamespaceMap=processNamespaces ? new HashMap() : null;
  HashMap currentNamespaceMap=null;
  final ArrayList namespaceMapStack=new ArrayList();
  char[] buffer=myBuffer;
  final ZLMutableString tagName=myTagName;
  final ZLMutableString attributeName=myAttributeName;
  final ZLMutableString attributeValue=myAttributeValue;
  final boolean dontCacheAttributeValues=xmlReader.dontCacheAttributeValues();
  final ZLMutableString entityName=myEntityName;
  final HashMap strings=ourStringMap;
  final ZLStringMap attributes=new ZLStringMap();
  String[] tagStack=new String[10];
  int tagStackSize=0;
  byte state=START_DOCUMENT;
  byte savedState=START_DOCUMENT;
  while (true) {
    int count=streamReader.read(buffer);
    if (count <= 0) {
      streamReader.close();
      return;
    }
    int startPosition=0;
    if (count < buffer.length) {
      startPosition=buffer.length - count;
      System.arraycopy(buffer,0,buffer,startPosition,count);
      count=buffer.length;
    }
    try {
      for (int i=startPosition - 1; ; ) {
        mainSwitchLabel: switch (state) {
case START_DOCUMENT:
          while (true) {
switch (buffer[++i]) {
case '<':
              state=LANGLE;
            startPosition=i + 1;
          break mainSwitchLabel;
      }
    }
case LANGLE:
switch (buffer[++i]) {
case '/':
    state=END_TAG;
  startPosition=i + 1;
break;
case '!':
case '?':
state=COMMENT;
break;
default :
state=START_TAG;
startPosition=i;
break;
}
break;
case COMMENT:
while (true) {
switch (buffer[++i]) {
case '>':
state=TEXT;
startPosition=i + 1;
break mainSwitchLabel;
}
}
case START_TAG:
while (true) {
switch (buffer[++i]) {
case 0x0008:
case 0x0009:
case 0x000A:
case 0x000B:
case 0x000C:
case 0x000D:
case ' ':
state=WS_AFTER_START_TAG_NAME;
tagName.append(buffer,startPosition,i - startPosition);
break mainSwitchLabel;
case '>':
state=TEXT;
tagName.append(buffer,startPosition,i - startPosition);
{
String stringTagName=convertToString(strings,tagName);
if (tagStackSize == tagStack.length) {
tagStack=ZLArrayUtils.createCopy(tagStack,tagStackSize,tagStackSize << 1);
}
tagStack[tagStackSize++]=stringTagName;
if (processNamespaces) {
if (currentNamespaceMap != null) {
oldNamespaceMap=currentNamespaceMap;
}
namespaceMapStack.add(currentNamespaceMap);
}
if (processStartTag(xmlReader,stringTagName,attributes,currentNamespaceMap)) {
streamReader.close();
return;
}
currentNamespaceMap=null;
}
startPosition=i + 1;
break mainSwitchLabel;
case '/':
state=SLASH;
tagName.append(buffer,startPosition,i - startPosition);
if (processFullTag(xmlReader,convertToString(strings,tagName),attributes)) {
streamReader.close();
return;
}
currentNamespaceMap=null;
break mainSwitchLabel;
case '&':
savedState=START_TAG;
tagName.append(buffer,startPosition,i - startPosition);
state=ENTITY_REF;
startPosition=i + 1;
break mainSwitchLabel;
}
}
case WS_AFTER_START_TAG_NAME:
switch (buffer[++i]) {
case '>':
{
String stringTagName=convertToString(strings,tagName);
if (tagStackSize == tagStack.length) {
tagStack=ZLArrayUtils.createCopy(tagStack,tagStackSize,tagStackSize << 1);
}
tagStack[tagStackSize++]=stringTagName;
if (processNamespaces) {
if (currentNamespaceMap != null) {
oldNamespaceMap=currentNamespaceMap;
}
namespaceMapStack.add(currentNamespaceMap);
}
if (processStartTag(xmlReader,stringTagName,attributes,currentNamespaceMap)) {
streamReader.close();
return;
}
currentNamespaceMap=null;
}
state=TEXT;
startPosition=i + 1;
break;
case '/':
state=SLASH;
if (processFullTag(xmlReader,convertToString(strings,tagName),attributes)) {
streamReader.close();
return;
}
currentNamespaceMap=null;
break;
case 0x0008:
case 0x0009:
case 0x000A:
case 0x000B:
case 0x000C:
case 0x000D:
case ' ':
break;
default :
state=ATTRIBUTE_NAME;
startPosition=i;
break;
}
break;
case ATTRIBUTE_NAME:
while (true) {
switch (buffer[++i]) {
case '=':
attributeName.append(buffer,startPosition,i - startPosition);
state=WAIT_ATTRIBUTE_VALUE;
break mainSwitchLabel;
case '&':
attributeName.append(buffer,startPosition,i - startPosition);
savedState=ATTRIBUTE_NAME;
state=ENTITY_REF;
startPosition=i + 1;
break mainSwitchLabel;
case 0x0008:
case 0x0009:
case 0x000A:
case 0x000B:
case 0x000C:
case 0x000D:
case ' ':
attributeName.append(buffer,startPosition,i - startPosition);
state=WAIT_EQUALS;
break mainSwitchLabel;
}
}
case WAIT_EQUALS:
while (true) {
switch (buffer[++i]) {
case '=':
state=WAIT_ATTRIBUTE_VALUE;
break mainSwitchLabel;
}
}
case WAIT_ATTRIBUTE_VALUE:
while (true) {
switch (buffer[++i]) {
case '"':
state=ATTRIBUTE_VALUE;
startPosition=i + 1;
break mainSwitchLabel;
}
}
case WS_AFTER_ATTRIBUTE_VALUE:
switch (buffer[++i]) {
case 0x0008:
case 0x0009:
case 0x000A:
case 0x000B:
case 0x000C:
case 0x000D:
case ' ':
state=WS_AFTER_START_TAG_NAME;
break;
case '/':
case '>':
state=WS_AFTER_START_TAG_NAME;
--i;
break;
case '"':
if (i != 0) {
attributeValue.append(buffer,i - 1,1);
}
break mainSwitchLabel;
default :
state=ATTRIBUTE_VALUE;
break mainSwitchLabel;
}
final String aName=convertToString(strings,attributeName);
if (processNamespaces && aName.startsWith("xmlns:")) {
if (currentNamespaceMap == null) {
currentNamespaceMap=new HashMap(oldNamespaceMap);
}
currentNamespaceMap.put(attributeValue.toString(),aName.substring(6));
attributeValue.clear();
}
 else if (dontCacheAttributeValues) {
attributes.put(aName,attributeValue.toString());
attributeValue.clear();
}
 else {
attributes.put(aName,convertToString(strings,attributeValue));
}
break;
case ATTRIBUTE_VALUE:
while (true) {
switch (buffer[++i]) {
case '"':
attributeValue.append(buffer,startPosition,i - startPosition);
state=WS_AFTER_ATTRIBUTE_VALUE;
break mainSwitchLabel;
case '&':
attributeValue.append(buffer,startPosition,i - startPosition);
savedState=ATTRIBUTE_VALUE;
state=ENTITY_REF;
startPosition=i + 1;
break mainSwitchLabel;
}
}
case ENTITY_REF:
while (true) {
switch (buffer[++i]) {
case ';':
entityName.append(buffer,startPosition,i - startPosition);
state=savedState;
startPosition=i + 1;
final char[] value=getEntityValue(entityMap,convertToString(strings,entityName));
if ((value != null) && (value.length != 0)) {
switch (state) {
case ATTRIBUTE_VALUE:
attributeValue.append(value,0,value.length);
break;
case ATTRIBUTE_NAME:
attributeName.append(value,0,value.length);
break;
case START_TAG:
tagName.append(value,0,value.length);
break;
case TEXT:
xmlReader.characterDataHandler(value,0,value.length);
break;
}
}
break mainSwitchLabel;
}
}
case SLASH:
while (true) {
switch (buffer[++i]) {
case '>':
state=TEXT;
startPosition=i + 1;
break mainSwitchLabel;
}
}
case END_TAG:
while (true) {
switch (buffer[++i]) {
case '>':
if (tagStackSize > 0) {
if (processNamespaces && (namespaceMapStack.remove(tagStackSize - 1) != null)) {
for (int j=namespaceMapStack.size() - 1; j >= 0; --j) {
Object element=namespaceMapStack.get(j);
if (element != null) {
oldNamespaceMap=(HashMap)element;
currentNamespaceMap=oldNamespaceMap;
break;
}
}
}
if (processEndTag(xmlReader,tagStack[--tagStackSize],currentNamespaceMap)) {
streamReader.close();
return;
}
currentNamespaceMap=null;
}
state=TEXT;
startPosition=i + 1;
break mainSwitchLabel;
}
}
case TEXT:
while (true) {
switch (buffer[++i]) {
case '<':
if (i > startPosition) {
xmlReader.characterDataHandlerFinal(buffer,startPosition,i - startPosition);
}
state=LANGLE;
break mainSwitchLabel;
case '&':
if (i > startPosition) {
xmlReader.characterDataHandler(buffer,startPosition,i - startPosition);
}
savedState=TEXT;
state=ENTITY_REF;
startPosition=i + 1;
break mainSwitchLabel;
}
}
}
}
}
 catch (ArrayIndexOutOfBoundsException e) {
if (count > startPosition) {
switch (state) {
case START_TAG:
tagName.append(buffer,startPosition,count - startPosition);
break;
case ATTRIBUTE_NAME:
attributeName.append(buffer,startPosition,count - startPosition);
break;
case ATTRIBUTE_VALUE:
attributeValue.append(buffer,startPosition,count - startPosition);
break;
case ENTITY_REF:
entityName.append(buffer,startPosition,count - startPosition);
break;
case TEXT:
xmlReader.characterDataHandler(buffer,startPosition,count - startPosition);
break;
}
}
}
}
}
