{
  final LinkedList<FBTree> toRemove=new LinkedList<FBTree>();
  ListIterator<FBTree> nodeIterator=subTrees().listIterator();
  FBTree currentNode=null;
  int nodeCount=0;
  for (int i=0; i < myChildrenItems.size(); ++i) {
    NetworkItem currentItem=myChildrenItems.get(i);
    if (!(currentItem instanceof NetworkCatalogItem)) {
      continue;
    }
    boolean processed=false;
    while (currentNode != null || nodeIterator.hasNext()) {
      if (currentNode == null) {
        currentNode=nodeIterator.next();
      }
      if (!(currentNode instanceof NetworkCatalogTree)) {
        currentNode=null;
        ++nodeCount;
        continue;
      }
      NetworkCatalogTree child=(NetworkCatalogTree)currentNode;
      if (child.Item == currentItem) {
switch (child.Item.getVisibility()) {
case B3_TRUE:
          child.updateVisibility();
        break;
case B3_FALSE:
      toRemove.add(child);
    break;
case B3_UNDEFINED:
  child.clearCatalog();
break;
}
currentNode=null;
++nodeCount;
processed=true;
break;
}
 else {
boolean found=false;
for (int j=i + 1; j < myChildrenItems.size(); ++j) {
if (child.Item == myChildrenItems.get(j)) {
found=true;
break;
}
}
if (!found) {
toRemove.add(currentNode);
currentNode=null;
++nodeCount;
}
 else {
break;
}
}
}
final int nextIndex=nodeIterator.nextIndex();
if (!processed && NetworkTreeFactory.createNetworkTree(this,currentItem,nodeCount) != null) {
++nodeCount;
nodeIterator=subTrees().listIterator(nextIndex + 1);
}
}
while (currentNode != null || nodeIterator.hasNext()) {
if (currentNode == null) {
currentNode=nodeIterator.next();
}
if (currentNode instanceof NetworkCatalogTree) {
toRemove.add(currentNode);
}
currentNode=null;
}
for (FBTree tree : toRemove) {
tree.removeSelf();
}
}
