{
  final List<ZLTextRegion> elementRegions=myCurrentPage.TextElementMap.elementRegions();
  if (elementRegions.isEmpty()) {
    return null;
  }
  final ZLTextRegion selectedRegion=getSelectedRegion();
  int index=selectedRegion != null ? elementRegions.indexOf(selectedRegion) : -1;
switch (direction) {
case rightToLeft:
case up:
    if (index == -1) {
      index=elementRegions.size() - 1;
    }
 else     if (index == 0) {
      return null;
    }
 else {
      --index;
    }
  break;
case leftToRight:
case down:
if (index == elementRegions.size() - 1) {
  return null;
}
 else {
  ++index;
}
break;
}
switch (direction) {
case rightToLeft:
for (; index >= 0; --index) {
final ZLTextRegion candidate=elementRegions.get(index);
if (filter.accepts(candidate) && candidate.isAtLeftOf(selectedRegion)) {
return candidate;
}
}
break;
case leftToRight:
for (; index < elementRegions.size(); ++index) {
final ZLTextRegion candidate=elementRegions.get(index);
if (filter.accepts(candidate) && candidate.isAtRightOf(selectedRegion)) {
return candidate;
}
}
break;
case down:
{
ZLTextRegion firstCandidate=null;
for (; index < elementRegions.size(); ++index) {
final ZLTextRegion candidate=elementRegions.get(index);
if (!filter.accepts(candidate)) {
continue;
}
if (candidate.isExactlyUnder(selectedRegion)) {
return candidate;
}
if (firstCandidate == null && candidate.isUnder(selectedRegion)) {
firstCandidate=candidate;
}
}
if (firstCandidate != null) {
return firstCandidate;
}
break;
}
case up:
ZLTextRegion firstCandidate=null;
for (; index >= 0; --index) {
final ZLTextRegion candidate=elementRegions.get(index);
if (!filter.accepts(candidate)) {
continue;
}
if (candidate.isExactlyOver(selectedRegion)) {
return candidate;
}
if (firstCandidate == null && candidate.isOver(selectedRegion)) {
firstCandidate=candidate;
}
}
if (firstCandidate != null) {
return firstCandidate;
}
break;
}
return null;
}
