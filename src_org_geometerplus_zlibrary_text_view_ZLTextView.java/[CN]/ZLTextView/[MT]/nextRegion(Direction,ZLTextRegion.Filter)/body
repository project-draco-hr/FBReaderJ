{
  final ArrayList<ZLTextRegion> elementRegions=myCurrentPage.TextElementMap.ElementRegions;
  if (elementRegions.isEmpty()) {
    return null;
  }
  int index=elementRegions.indexOf(mySelectedRegion);
  mySelectedRegion=index >= 0 ? elementRegions.get(index) : null;
switch (direction) {
case rightToLeft:
case up:
    if (index == -1) {
      index=elementRegions.size() - 1;
    }
 else     if (index == 0) {
      return null;
    }
 else {
      --index;
    }
  break;
case leftToRight:
case down:
if (index == elementRegions.size() - 1) {
  return null;
}
 else {
  ++index;
}
break;
}
switch (direction) {
case rightToLeft:
for (; index >= 0; --index) {
final ZLTextRegion candidate=elementRegions.get(index);
if (filter.accepts(candidate) && candidate.isAtLeftOf(mySelectedRegion)) {
return candidate;
}
}
break;
case leftToRight:
for (; index < elementRegions.size(); ++index) {
final ZLTextRegion candidate=elementRegions.get(index);
if (filter.accepts(candidate) && candidate.isAtRightOf(mySelectedRegion)) {
return candidate;
}
}
break;
case down:
{
ZLTextRegion firstCandidate=null;
for (; index < elementRegions.size(); ++index) {
final ZLTextRegion candidate=elementRegions.get(index);
if (!filter.accepts(candidate)) {
continue;
}
if (candidate.isExactlyUnder(mySelectedRegion)) {
return candidate;
}
if (firstCandidate == null && candidate.isUnder(mySelectedRegion)) {
firstCandidate=candidate;
}
}
if (firstCandidate != null) {
return firstCandidate;
}
break;
}
case up:
ZLTextRegion firstCandidate=null;
for (; index >= 0; --index) {
final ZLTextRegion candidate=elementRegions.get(index);
if (!filter.accepts(candidate)) {
continue;
}
if (candidate.isExactlyOver(mySelectedRegion)) {
return candidate;
}
if (firstCandidate == null && candidate.isOver(mySelectedRegion)) {
firstCandidate=candidate;
}
}
if (firstCandidate != null) {
return firstCandidate;
}
break;
}
return null;
}
