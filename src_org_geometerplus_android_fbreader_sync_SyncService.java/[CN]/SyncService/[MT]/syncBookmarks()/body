{
  try {
    final Map<String,BookmarkInfo> actualServerInfos=new HashMap<String,BookmarkInfo>();
    final Set<String> deletedOnServerUids=new HashSet<String>();
    final ZLNetworkRequest infoRequest=loadBookmarksInfo(actualServerInfos,deletedOnServerUids);
    System.err.println("BMK ACTUAL = " + actualServerInfos);
    System.err.println("BMK DELETED = " + deletedOnServerUids);
    final Set<String> deletedOnClientUids=new HashSet<String>(myCollection.deletedBookmarkUids());
    if (!deletedOnClientUids.isEmpty()) {
      final List<String> toPurge=new ArrayList<String>(deletedOnClientUids);
      toPurge.removeAll(actualServerInfos.keySet());
      if (!toPurge.isEmpty()) {
        myCollection.purgeBookmarks(toPurge);
      }
    }
    final List<Bookmark> toSendToServer=new LinkedList<Bookmark>();
    final List<Bookmark> toDeleteOnClient=new LinkedList<Bookmark>();
    final List<Bookmark> toUpdateOnServer=new LinkedList<Bookmark>();
    final List<Bookmark> toUpdateOnClient=new LinkedList<Bookmark>();
    final List<String> toGetFromServer=new LinkedList<String>();
    final List<String> toDeleteOnServer=new LinkedList<String>();
    for (BookmarkQuery q=new BookmarkQuery(20); ; q=q.next()) {
      final List<Bookmark> bmks=myCollection.bookmarks(q);
      if (bmks.isEmpty()) {
        break;
      }
      for (      Bookmark b : bmks) {
        final BookmarkInfo info=actualServerInfos.remove(b.Uid);
        if (info != null) {
          if (info.VersionUid == null) {
            if (b.getVersionUid() != null) {
              toUpdateOnServer.add(b);
            }
          }
 else {
            if (b.getVersionUid() == null) {
              toUpdateOnClient.add(b);
            }
 else             if (!info.VersionUid.equals(b.getVersionUid())) {
              final long ts=b.getDate(Bookmark.DateType.Modification).getTime();
              if (info.ModificationTimestamp <= ts) {
                toUpdateOnServer.add(b);
              }
 else {
                toUpdateOnClient.add(b);
              }
            }
          }
        }
 else         if (deletedOnServerUids.contains(b.Uid)) {
          toDeleteOnClient.add(b);
        }
 else {
          toSendToServer.add(b);
        }
      }
    }
    final Set<String> leftUids=actualServerInfos.keySet();
    if (!leftUids.isEmpty()) {
      toGetFromServer.addAll(leftUids);
      toGetFromServer.removeAll(deletedOnClientUids);
      toDeleteOnServer.addAll(leftUids);
      toDeleteOnServer.retainAll(deletedOnClientUids);
    }
    System.err.println("BMK TO SEND TO SERVER = " + ids(toSendToServer));
    System.err.println("BMK TO DELETE ON SERVER = " + toDeleteOnServer);
    System.err.println("BMK TO DELETE ON CLIENT = " + ids(toDeleteOnClient));
    System.err.println("BMK TO UPDATE ON SERVER = " + ids(toUpdateOnServer));
    System.err.println("BMK TO UPDATE ON CLIENT = " + ids(toUpdateOnClient));
    System.err.println("BMK TO GET FROM SERVER = " + toGetFromServer);
class HashCache {
      final Map<Long,String> myHashByBookId=new HashMap<Long,String>();
      String getHash(      Bookmark b){
        String hash=myHashByBookId.get(b.BookId);
        if (hash == null) {
          final Book book=myCollection.getBookById(b.BookId);
          hash=book != null ? myCollection.getHash(book,false) : "";
          myHashByBookId.put(b.BookId,hash);
        }
        return "".equals(hash) ? null : hash;
      }
    }
    ;
    final HashCache cache=new HashCache();
    final List<BookmarkSync.Request> requests=new ArrayList<BookmarkSync.Request>();
    for (    Bookmark b : toSendToServer) {
      final String hash=cache.getHash(b);
      if (hash != null) {
        requests.add(new BookmarkSync.AddRequest(b,hash));
      }
    }
    for (    Bookmark b : toUpdateOnServer) {
      final String hash=cache.getHash(b);
      if (hash != null) {
        requests.add(new BookmarkSync.UpdateRequest(b,hash));
      }
    }
    for (    String uid : toDeleteOnServer) {
      requests.add(new BookmarkSync.DeleteRequest(uid));
    }
    final Map<String,Object> dataForSending=new HashMap<String,Object>();
    dataForSending.put("requests",requests);
    dataForSending.put("timestamp",System.currentTimeMillis());
    final ZLNetworkRequest serverUpdateRequest=new JsonRequest2(SyncOptions.BASE_URL + "sync/update.bookmarks",dataForSending){
      @Override public void processResponse(      Object response){
        System.err.println("UPDATED: " + response);
      }
    }
;
    final String csrfToken=mySyncBookmarksContext.getCookieValue(SyncOptions.DOMAIN,"csrftoken");
    serverUpdateRequest.addHeader("Referer",infoRequest.getURL());
    serverUpdateRequest.addHeader("X-CSRFToken",csrfToken);
    mySyncBookmarksContext.perform(serverUpdateRequest);
    for (    Bookmark b : toDeleteOnClient) {
      myCollection.deleteBookmark(b);
    }
    for (    Bookmark b : toUpdateOnClient) {
    }
    for (    String b : toGetFromServer) {
    }
  }
 catch (  Throwable t) {
    t.printStackTrace();
  }
}
