{
  final FileInfoSet fileInfos=new FileInfoSet();
  final Map<Long,Book> savedBooksByFileId=BooksDatabase.Instance().loadBooks(fileInfos,true);
  final Map<Long,Book> savedBooksByBookId=new HashMap<Long,Book>();
  for (  Book b : savedBooksByFileId.values()) {
    savedBooksByBookId.put(b.getId(),b);
  }
  final BooksDatabase db=BooksDatabase.Instance();
  for (  long id : db.loadRecentBookIds()) {
    final Book book=savedBooksByBookId.get(id);
    if (book != null) {
      new BookTree(getFirstLevelTree(ROOT_RECENT),book,true);
    }
  }
  for (  long id : db.loadFavoritesIds()) {
    final Book book=savedBooksByBookId.get(id);
    if (book != null) {
      getFirstLevelTree(ROOT_FAVORITES).getBookSubTree(book,true);
    }
  }
  fireModelChangedEvent();
  boolean doGroupTitlesByFirstLetter=false;
  if (savedBooksByFileId.size() > 10) {
    final HashSet<String> letterSet=new HashSet<String>();
    for (    Book book : savedBooksByFileId.values()) {
      final String letter=TitleTree.firstTitleLetter(book);
      if (letter != null) {
        letterSet.add(letter);
      }
    }
    doGroupTitlesByFirstLetter=savedBooksByFileId.values().size() > letterSet.size() * 5 / 4;
  }
  final Set<Book> orphanedBooks=new HashSet<Book>();
  for (  Book book : savedBooksByFileId.values()) {
    if (book.File.exists()) {
      addBookToLibrary(book,doGroupTitlesByFirstLetter);
    }
 else {
      myRootTree.removeBook(book);
      orphanedBooks.add(book);
    }
    fireModelChangedEvent();
  }
  BooksDatabase.Instance().setExistingFlag(orphanedBooks,false);
  final Map<Long,Book> orphanedBooksByFileId=BooksDatabase.Instance().loadBooks(fileInfos,true);
  final Set<Book> existingBooks=new HashSet<Book>();
  final Set<Book> newBooks=new HashSet<Book>();
  myState=STATE_FULLY_INITIALIZED;
}
